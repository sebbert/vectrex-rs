#[derive(Debug)]
pub struct Instruction(pub Mnemonic, pub Addressing);

#[derive(Debug)]
pub enum Addressing {
	Inherent,
	Immediate8(u8),
	Immediate16(u16),
	Relative8(i8),
	Relative16(i16),
	Direct(u8),
	Extended(u16),
	Indexed(IndexMode),
}

#[derive(Debug)]
pub enum Register {
	D,
	X,
	Y,
	U,
	S,
	Pc,
	A,
	B,
	Cc,
	Dp
}

impl Register {
	pub fn from_indexed_halfnibble(halfnibble: u8) -> Option<Register> {
		match halfnibble {
			0b00 => Some(Register::X),
			0b01 => Some(Register::Y),
			0b10 => Some(Register::U),
			0b11 => Some(Register::S),
			_ => None
		}
	}
}

#[derive(Debug)]
pub enum IndexMode {
	Offset0 { reg: Register, indirect: bool },
	Offset5 { reg: Register, offset: i8 },
	Offset8 { reg: Register, offset: i8, indirect: bool },
	Offset16 { reg: Register, offset: i16, indirect: bool },
	OffsetA { reg: Register, indirect: bool },
	OffsetB { reg: Register, indirect: bool },
	OffsetD { reg: Register, indirect: bool },
	Increment1 { reg: Register },
	Increment2 { reg: Register, indirect: bool },
	Decrement1 { reg: Register },
	Decrement2 { reg: Register, indirect: bool },
	PcOffset8 { offset: i8, indirect: bool },
	PcOffset16 { offset: i16, indirect: bool },
	ExtendedIndirect { address: u16 }
}

#[derive(Debug)]
pub enum Mnemonic {
	Abx,
	Adca,
	Adcb,
	Adda,
	Addb,
	Addd,
	Anda,
	Andb,
	Andcc,
	Asla,
	Aslb,
	Asl,
	Asra,
	Asrb,
	Asr,
	Bita,
	Bitb,
	Clra,
	Clrb,
	Clr,
	Cmpa,
	Cmpb,
	Cmpd,
	Cmps,
	Cmpu,
	Cmpx,
	Cmpy,
	Lsra,
	Lsrb,
	Lsr,
	Mul,
	Nega,
	Negb,
	Neg,
	Nop,
	Ora,
	Orb,
	Orcc,
	Pshs,
	Pshu,
	Puls,
	Pulu,
	Rola,
	Rolb,
	Rol,
	Rora,
	Rorb,
	Ror,
	Rti,
	Rts,
	Sbca,
	Sbcb,
	Sex,
	Coma,
	Comb,
	Com,
	Cwai,
	Daa,
	Deca,
	Decb,
	Dec,
	Eora,
	Eorb,
	Exg,
	Inca,
	Incb,
	Inc,
	Jmp,
	Jsr,
	Lda,
	Ldb,
	Ldd,
	Lds,
	Ldu,
	Ldx,
	Ldy,
	Leas,
	Leau,
	Leax,
	Leay,
	Sta,
	Stb,
	Std,
	Stu,
	Stx,
	Sty,
	Suba,
	Subb,
	Subd,
	Swi,
	Swi2,
	Swi3,
	Sync,
	Tfr,
	Tsta,
	Tstb,
	Tst,
	Beq,
	Bge,
	Bgt,
	Bhi,
	Bhs,
	Ble,
	Blo,
	Bls,
	Blt,
	Bmi,
	Bne,
	Bpl,
	Bra,
	Brn,
	Bsr,
	Bvc,
	Bvs,
}